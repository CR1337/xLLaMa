[
    [
        {
            "name": "DataFrame.size",
            "url": "https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.size.html",
            "description": "property DataFrame.size\n\nReturn an int representing the number of elements in this object.\n\nReturn the number of rows if Series. Otherwise return the number of rows times number of columns if DataFrame.\n\nSee also\n\nndarray.size\n\n    Number of elements in the array.\n\nExamples\n\n>>> s = pd.Series({'a': 1, 'b': 2, 'c': 3})\n>>> s.size\n3\n\n>>> df = pd.DataFrame({'col1': [1, 2], 'col2': [3, 4]})\n>>> df.size\n4",
            "source": "@final\n@property\ndef size(self) -> int:\n    return int(np.prod(self.shape))"
        },
        {
            "name": "DataFrame.empty",
            "url": "https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.empty.html",
            "description": "property DataFrame.empty[source]\n\nIndicator whether Series/DataFrame is empty.\n\nTrue if Series/DataFrame is entirely empty (no items), meaning any of the axes are of length 0.\n\nReturns:\n\n    bool\n\n        If Series/DataFrame is empty, return True, if not return False.\n\nSee also\n\nSeries.dropna\n\n    Return series without null values.\nDataFrame.dropna\n\n    Return DataFrame with labels on given axis omitted where (all or any) data are missing.\n\nNotes\n\nIf Series/DataFrame contains only NaNs, it is still not considered empty. See the example below.\n\nExamples\n\nAn example of an actual empty DataFrame. Notice the index is empty:\n\n>>> df_empty = pd.DataFrame({'A' : []})\n>>> df_empty\nEmpty DataFrame\nColumns: [A]\nIndex: []\n>>> df_empty.empty\nTrue\n\nIf we only have NaNs in our DataFrame, it is not considered empty! We will need to drop the NaNs to make the DataFrame empty:\n\n>>> df = pd.DataFrame({'A' : [np.nan]})\n>>> df\n    A\n0 NaN\n>>> df.empty\nFalse\n>>> df.dropna().empty\nTrue\n\n>>> ser_empty = pd.Series({'A' : []})\n>>> ser_empty\nA    []\ndtype: object\n>>> ser_empty.empty\nFalse\n>>> ser_empty = pd.Series()\n>>> ser_empty.empty\nTrue\n",
            "source": "@property\ndef empty(self) -> bool_t:\n    return any(len(self._get_axis(a)) == 0 for a in self._AXIS_ORDERS)"
        }
    ],
    [
        {
            "name": "tokenizer.convert_ids_to_tokens",
            "url": "https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizer.convert_ids_to_tokens",
            "description": "convert_ids_to_tokens\n\n( ids: typing.Union[int, typing.List[int]]skip_special_tokens: bool = False ) \u2192 str or List[str]\n\nParameters\n\nids (int or List[int]) \u2014 The token id (or token ids) to convert to tokens.\n\n    skip_special_tokens (bool, optional, defaults to False) \u2014 Whether or not to remove special tokens in the decoding.\n\nReturns\n\nstr or List[str]\n\nThe decoded token(s).\n\nConverts a single index or a sequence of indices in a token or a sequence of tokens, using the vocabulary and added tokens.",
            "source": "def convert_ids_to_tokens(\n    self, ids: Union[int, List[int]], skip_special_tokens: bool = False\n) -> Union[str, List[str]]:\n    if isinstance(ids, int):\n        if ids in self._added_tokens_decoder:\n            return self._added_tokens_decoder[ids].content\n        else:\n            return self._convert_id_to_token(ids)\n    tokens = []\n    for index in ids:\n        index = int(index)\n        if skip_special_tokens and index in self.all_special_ids:\n            continue\n        if index in self._added_tokens_decoder:\n            tokens.append(self._added_tokens_decoder[index].content)\n        else:\n            tokens.append(self._convert_id_to_token(index))\n    return tokens"
        }
    ],
    [
        {
            "name": "numpy.sum",
            "url": "https://numpy.org/doc/stable/reference/generated/numpy.sum.html",
            "description": "numpy.sum(a, axis=None, dtype=None, out=None, keepdims=<no value>, initial=<no value>, where=<no value>)\n\nSum of array elements over a given axis.\n\nParameters:\n\n    aarray_like\n\n        Elements to sum.\n    axisNone or int or tuple of ints, optional\n\n        Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.\n\n        New in version 1.7.0.\n\n        If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.\n    dtypedtype, optional\n\n        The type of the returned array and of the accumulator in which the elements are summed. The dtype of a is used by default unless a has an integer dtype of less precision than the default platform integer. In that case, if a is signed then the platform integer is used while if a is unsigned then an unsigned integer of the same precision as the platform integer is used.\n    outndarray, optional\n\n        Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.\n    keepdimsbool, optional\n\n        If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.\n\n        If the default value is passed, then keepdims will not be passed through to the sum method of sub-classes of ndarray, however any non-default value will be. If the sub-class\u2019 method does not implement keepdims any exceptions will be raised.\n    initialscalar, optional\n\n        Starting value for the sum. See reduce for details.\n\n        New in version 1.15.0.\n    wherearray_like of bool, optional\n\n        Elements to include in the sum. See reduce for details.\n\n        New in version 1.17.0.\n\nReturns:\n\n    sum_along_axisndarray\n\n        An array with the same shape as a, with the specified axis removed. If a is a 0-d array, or if axis is None, a scalar is returned. If an output array is specified, a reference to out is returned.\n\nSee also\n\nndarray.sum\n\n    Equivalent method.\nadd.reduce\n\n    Equivalent functionality of add.\ncumsum\n\n    Cumulative sum of array elements.\ntrapz\n\n    Integration of array values using the composite trapezoidal rule.\nmean, average\n\nNotes\n\nArithmetic is modular when using integer types, and no error is raised on overflow.\n\nThe sum of an empty array is the neutral element 0:\n\n>>> np.sum([])\n0.0\n\nFor floating point numbers the numerical precision of sum (and np.add.reduce) is in general limited by directly adding each number individually to the result causing rounding errors in every step. However, often numpy will use a numerically better approach (partial pairwise summation) leading to improved precision in many use-cases. This improved precision is always provided when no axis is given. When axis is given, it will depend on which axis is summed. Technically, to provide the best speed possible, the improved precision is only used when the summation is along the fast axis in memory. Note that the exact precision may vary depending on other parameters. In contrast to NumPy, Python\u2019s math.fsum function uses a slower but more precise approach to summation. Especially when summing a large number of lower precision floating point numbers, such as float32, numerical errors can become significant. In such cases it can be advisable to use dtype=\u201dfloat64\u201d to use a higher precision for the output.\n\nExamples\n\n>>> np.sum([0.5, 1.5])\n2.0\n>>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)\n1\n>>> np.sum([[0, 1], [0, 5]])\n6\n>>> np.sum([[0, 1], [0, 5]], axis=0)\narray([0, 6])\n>>> np.sum([[0, 1], [0, 5]], axis=1)\narray([1, 5])\n>>> np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)\narray([1., 5.])\n\nIf the accumulator is too small, overflow occurs:\n\n>>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)\n-128\n\nYou can also start the sum with a value other than zero:\n\n>>> np.sum([10], initial=5)\n15\n",
            "source": "@array_function_dispatch(_sum_dispatcher)\ndef sum(a, axis=None, dtype=None, out=None, keepdims=np._NoValue,\n        initial=np._NoValue, where=np._NoValue):\n    if isinstance(a, _gentype):\n        # 2018-02-25, 1.15.0\n        warnings.warn(\n            \\\"Calling np.sum(generator) is deprecated, and in the future will give a different result. \\\"\n            \\\"Use np.sum(np.fromiter(generator)) or the python sum builtin instead.\\\",\n            DeprecationWarning, stacklevel=2)\n\n        res = _sum_(a)\n        if out is not None:\n            out[...] = res\n            return out\n        return res\n\n    return _wrapreduction(a, np.add, 'sum', axis, dtype, out, keepdims=keepdims,\n                          initial=initial, where=where)\n"
        },
        {
            "name": "numpy.mean",
            "url": "https://numpy.org/doc/stable/reference/generated/numpy.mean.html",
            "description": "numpy.mean(a, axis=None, dtype=None, out=None, keepdims=<no value>, *, where=<no value>)[source]\n\nCompute the arithmetic mean along the specified axis.\n\nReturns the average of the array elements. The average is taken over the flattened array by default, otherwise over the specified axis. float64 intermediate and return values are used for integer inputs.\n\nParameters:\n\n    aarray_like\n\n        Array containing numbers whose mean is desired. If a is not an array, a conversion is attempted.\n    axisNone or int or tuple of ints, optional\n\n        Axis or axes along which the means are computed. The default is to compute the mean of the flattened array.\n\n        New in version 1.7.0.\n\n        If this is a tuple of ints, a mean is performed over multiple axes, instead of a single axis or all the axes as before.\n    dtypedata-type, optional\n\n        Type to use in computing the mean. For integer inputs, the default is float64; for floating point inputs, it is the same as the input dtype.\n    outndarray, optional\n\n        Alternate output array in which to place the result. The default is None; if provided, it must have the same shape as the expected output, but the type will be cast if necessary. See Output type determination for more details.\n    keepdimsbool, optional\n\n        If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.\n\n        If the default value is passed, then keepdims will not be passed through to the mean method of sub-classes of ndarray, however any non-default value will be. If the sub-class\u2019 method does not implement keepdims any exceptions will be raised.\n    wherearray_like of bool, optional\n\n        Elements to include in the mean. See reduce for details.\n\n        New in version 1.20.0.\n\nReturns:\n\n    mndarray, see dtype parameter above\n\n        If out=None, returns a new array containing the mean values, otherwise a reference to the output array is returned.\n\nSee also\n\naverage\n\n    Weighted average\nstd, var, nanmean, nanstd, nanvar\n\nNotes\n\nThe arithmetic mean is the sum of the elements along the axis divided by the number of elements.\n\nNote that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for float32 (see example below). Specifying a higher-precision accumulator using the dtype keyword can alleviate this issue.\n\nBy default, float16 results are computed using float32 intermediates for extra precision.\n\nExamples\n\n>>> a = np.array([[1, 2], [3, 4]])\n>>> np.mean(a)\n2.5\n>>> np.mean(a, axis=0)\narray([2., 3.])\n>>> np.mean(a, axis=1)\narray([1.5, 3.5])\n\nIn single precision, mean can be inaccurate:\n\n>>> a = np.zeros((2, 512*512), dtype=np.float32)\n>>> a[0, :] = 1.0\n>>> a[1, :] = 0.1\n>>> np.mean(a)\n0.54999924\n\nComputing the mean in float64 is more accurate:\n\n>>> np.mean(a, dtype=np.float64)\n0.55000000074505806 # may vary\n\nSpecifying a where argument:\n\n>>> a = np.array([[5, 9, 13], [14, 10, 12], [11, 15, 19]])\n>>> np.mean(a)\n12.0\n>>> np.mean(a, where=[[True], [False], [False]])\n9.0\n",
            "source": "@array_function_dispatch(_mean_dispatcher)\ndef mean(a, axis=None, dtype=None, out=None, keepdims=np._NoValue, *,\n         where=np._NoValue):\n    kwargs = {}\n    if keepdims is not np._NoValue:\n        kwargs['keepdims'] = keepdims\n    if where is not np._NoValue:\n        kwargs['where'] = where\n    if type(a) is not mu.ndarray:\n        try:\n            mean = a.mean\n        except AttributeError:\n            pass\n        else:\n            return mean(axis=axis, dtype=dtype, out=out, **kwargs)\n\n    return _methods._mean(a, axis=axis, dtype=dtype,\n                          out=out, **kwargs)"
        }
    ]
]